---
theme: sirius-college
exportFilename: pdf/op_lection_3
layout: cover
---

# Основы программирования<br>Лекция 3. 

Циклы. Кортежи. Словари. Множества.

---


# Цикл `while`

Инструкция `while` в Python повторяет указанный блок кода до тех пор, пока указанное в цикле условие будет оставаться истинным.

````md magic-move
```python
while <условие>:
    <выражение>
```

```python
apples = 5

while apples > 0:
    print('We have', apples, 'apples')
    apples -= 1

print('We have no apples any more!')
```
````

---

# Цикл `for`

Этот цикл проходится по любому итерируемому объекту (например, строке или списку), и во время каждого прохода выполняет тело цикла.

````md magic-move
```python
for <элемент> in <последовательность>:
    <выражение>
```

```python
for i in range(5):
    print(i)
```

```python
word = 'Слово'

for letter in word:
    print(letter)
```

```py
shopping_list = ['milk', 'bread', 'cucumber', 'butter']

for element in shopping_list:
    print(element)
```

```py
seasons = {1: 'Зима', 2: 'Весна', 3: 'Лето', 4: 'Осень'}

for s in seasons:
    print('Номер сезона:', s)
    print('Название:', seasons[s])
```
````

---

# Оператор `continue`

Оператор `continue` начинает следующий проход цикла, минуя оставшееся тело цикла (`for` или `while`). Пример:

```python
for letter in 'Стол':
    if letter == 'т':
        continue
    print(letter)
```

Результат выполнения:

```console {lines: false}
С
о
л
```

---

# Оператор `break`

Оператор `break` досрочно прерывает цикл.

```python
for letter in 'Стол':
    if letter == 'т':
      break
    print(letter)
```

Результат выполнения:

```console {lines: false}
С
```

---

# `else` в циклах

Циклы `for` и `while` в Python имеют свою конструкцию `else`, которая выполняется после завершения цикла.

````md magic-move
```python
for letter in 'Стол':
    print(letter)
else:
    print("Цикл завершился нормально")
```

```python
for letter in 'Стол':
    if letter == 'т':
        continue
    print(letter)
else:
    print("Цикл завершился нормально")
```

```python
for letter in 'Стол':
    if letter == 'т':
        break
    print(letter)
else:
    print("Цикл завершился нормально")
```
````

````md magic-move {at:1, lines: false}
```console
С
т
о
л
Цикл завершился нормально
```

```console
С
т
о
л
Цикл завершился нормально
```

```console
С
```
````

---

# Функция `range()`

Функция `range()` генерирует последовательность чисел, которую часто используют для итерации в циклах `for`. Она может принимать от одного до трёх аргументов: `start`, `stop` и `step`.

````md magic-move

```python
for i in range(5):  # Генерирует числа от 0 до 4
    print(i)
```

```python
for i in range(2, 10):  # Генерирует числа от 2 до 9
    print(i)
```

```python
for i in range(1, 10, 2):  # Генерирует нечётные числа от 1 до 9
    print(i)
```
````

````md magic-move {at:1, lines:false}

```console
0
1
2
3
4
```
```console
2
3
4
5
6
7
8
9
```
```console
1
3
5
7
9
```
````

---

# Функция `enumerate()`

Функция `enumerate()` добавляет счётчик к итерируемому объекту и возвращает его в виде объекта перечисления. Это полезно, когда нужно получить индекс элемента вместе с самим элементом при итерации.

```python
words = ['apple', 'banana', 'cherry']

for index, word in enumerate(words):
    print(index, word)
```

---

# Функция `zip()`

Функция `zip()` принимает несколько итерируемых объектов и возвращает итератор, который генерирует кортежи, состоящие из элементов переданных итерируемых объектов, взятых по одному из каждого.

```python
names = ['Анна', 'Борис', 'Виктор']
ages = [25, 30, 35]

for name, age in zip(names, ages):
    print(name, age)
```

---

# Кортежи (tuple)

- Кортежи служат для хранения нескольких объектов вместе. Их можно рассматривать как аналог списков, но без такой обширной функциональности, которую предоставляет класс списка.
- Одна из важнейших особенностей кортежей заключается в том, что они неизменяемы.
- Кортежи обозначаются указанием элементов, разделённых запятыми; по желанию их можно ещё заключить в круглые скобки.
- Кортежи обычно используются в тех случаях, когда оператор или пользовательская функция должны наверняка знать, что набор значений, т.е. кортеж значений, не изменится.
- Элементы кортежа могут быть любого неизменяемого типа данных, включая числа, строки и даже другие кортежи.

---

# Примеры кортежей

```python
zoo = ('python', 'elephant', 'pinguin')
new_zoo = 'monkey', 'cheetah'
```

Несмотря на то, что кортежи можно объявлять и использовать без скобок, является хорошей практикой обособлять их скобками.

> Явное лучше неявного.

---

# Особенности минимальных кортежей

- Пустой кортеж объявляется очень просто - с помощью пустых скобок `()`.
- Кортеж из одного элемента объявляется с помощью конструкции скобок, элемента в них, а также запятой после этого единственного элемента, вот так:

```python
(2,)
```

Так интерпретатор Python поймёт, что вы не просто заключили какое-то значение в скобки, а именно определяете кортеж.

---

# Особенности использования кортежей

- Передавая кортеж функции, необходимо дублировать скобки. Например, эти две строки кода выполняют разные задачи:

```python
print(1, 2, 3)
```

и

```python
print( (1, 2, 3) )
```

- Первый код отправит в стандартный вывод значения `1, 2, 3`.
- Второй код отправит в него кортеж `(1, 2, 3)`. Внешние скобки заключают аргументы, передаваемые функции `print`. Внутренние заключают кортеж.

---

# Словари (dictionaries)

- Словарь – это структура данных, в которой уникальные ключи (имена) связаны со значениями (информацией).
- Заметьте, что ключ должен быть именно уникальным, и это обязательно.
- Также важно, что в качестве ключей могут служить только
  неизменяемые (хешируемые) типы данных, в то время как в качестве значений
  можно использовать как изменяемые, так и неизменяемые типы
  данных.

---

# Создание и инициализация словарей

````md magic-move
```python
# Пустой словарь
>> my_dict = {}  
{}
>> my_dict = dict()
{}
```

```python
# Словарь с начальными значениями
>> student = {'group' : '09.02.07', 'age' : 18 }
{'group' : '09.02.07', 'age' : 18 }
```

```python
# Словарь с начальными значениями
>> student = dict(group='09.02.07', age=18)
{'group' : '09.02.07', 'age' : 18 }
```

```python
# Словарь с начальными значениями
>> student = dict([('group', '09.02.07'), ('age', 18)])
{'group' : '09.02.07', 'age' : 18 }
```

```python
# Dictionary comprehension
>> student = {k: v for k, v in [('group', '09.02.07'), ('age', 18)]}
{'group' : '09.02.07', 'age' : 18 }
```

```python
# Dictionary comprehension
>> student = {k: v for k, v in zip(['group', 'age'], ['09.02.07', 18])}
{'group' : '09.02.07', 'age' : 18 }
```

```python
# Dictionary comprehension
>> student = {k: v for k, v in enumerate(['09.02.07', 18])}
{0: '09.02.07', 1: 18 }
```

```python
# из списка ключей
>> keys = ['group', 'age']
>> dict.fromkeys(keys)
{'group' : None, 'age' : None }
```

```python
# из списка ключей с одним значением по умолчанию
>> keys = ['group', 'age']
>> dict.fromkeys(keys, 18)
{'group' : 18, 'age' : 18 }
```
````

---

# Примеры словарей

```python
student_1 = {'group' : '09.02.01', 'age' : 18 }
student_2 = {'group' : '09.02.06', 'age' : 18 }
```

<v-click>

Получение значения по ключу словаря использует конструкцию
`имя_словаря[ключ]`:

```python
student_1['age'] == 18
```

</v-click>

<v-click>

Так же можно использовать метод `get()` для получения значения по ключу:

```python
student_1.get('age') == 18
```
</v-click>
<v-click>

В случае, если ключ отсутствует в словаре, метод `get()` вернёт `None` или значение по умолчанию, если оно указано:

```python
>> student_1.get('course', "no course")
"no course"
```
</v-click>

---

# Примеры словарей

В качестве значений словарь может использовать другие словари:

```python
students = {'Ivan' : student_1, 'Petr' : student_2}
```

Таким образом:

```python
{'Ivan' : {'group' : '09.02.01', 'age' : 18 },
 'Petr' : {'group' : '09.02.06', 'age' : 18 }}
```

Получить значение из вложенного словаря можно получить с помощью конструкции `имя_словаря[ключ_1][ключ_2]`:

```python
students['Ivan']['group'] == '09.02.01'
```

---

# Методы `keys(), values(), items()`

Вывести список ключей словаря можно с помощью метода `keys()`:

```python
students.keys() == ['Ivan', 'Petr']
```

Вывести список значений словаря можно с помощью метода `values()`:

```python
student_1.values() == ['09.02.01', 18]
```

Вывести список кортежей словаря "ключ-значение" можно с помощью метода `items()`:

```python
student1.items() == [
    ('group', '09.02.01'),
    ('age', 18)
    ]
```

---

# Множество (set)

- Множество - это структура данных, содержащая уникальные элементы в случайном порядке.
- Создать пустое множество можно с помощью фигурных скобок `{}` или с помощью функции `set()`.
- Примечательно, что если передать функции `set()` любой итерируемый тип данных с неуникальными элементами, то эта функция вернёт множество уникальных элементов из переданных ей.

```python
set(['student', 'professor', 'student']) == {'student', 'professor'}
set('hello') == {'h', 'e', 'l', 'o'}
```

---

# Операции с множествами

- `len(s)` - число элементов в множестве (размер множества).
- `x in s` - принадлежит ли `x` множеству `s`.
- `set.isdisjoint(other)` - истина, если `set` и other не имеют общих элементов.
- `set == other` - все элементы set принадлежат other, все элементы other принадлежат `set`.
- `set.issubset(other)` или `set <= other` - все элементы `set` принадлежат other.
- `set.issuperset(other)` или `set >= other` - аналогично.
- `set.union(other, ...)` или `set | other | ...` - объединение нескольких множеств.
- `set.intersection(other, ...)` или `set & other & ...` - пересечение.
- `set.difference(other, ...)` или `set - other - ...` - множество из всех элементов `set`, не принадлежащие ни одному из `other`.

---

# Операции с множествами

- `set.symmetric_difference(other)`; `set ^ other` - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
- `set.update(other, ...)`; `set |= other | ...` - объединение.
- `set.intersection_update(other, ...)`; `set &= other & ...` - пересечение.
- `set.difference_update(other, ...)`; `set -= other | ...` - вычитание.
- `set.symmetric_difference_update(other)`; `set ^= other` - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
- `set.add(elem)` - добавляет элемент в множество.
- `set.remove(elem)` - удаляет элемент из множества. `KeyError`, если такого элемента не существует.
- `set.discard(elem)` - удаляет элемент, если он находится в множестве.
- `set.pop()` - удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым.
- `set.clear()` - очистка множества.

---

# `frozenset`

Единственное отличие `set` от `frozenset` заключается в том, что `set` - изменяемый тип данных, а `frozenset` - нет. Примерно похожая ситуация с списками и кортежами.

```python
a = set('qwerty')
b = frozenset('qwerty')
a.add(1)
b.add(1)
```

```console {}{lines:false}
Traceback (most recent call last):
File "<stdin>", line 4, in <module>
AttributeError: 'frozenset' object has no attribute 'add'
```
